#! <?xml version="1.0" encoding="UTF-8" ?>
#! <WORKSPACE
#    
#    
#    Command-line to run this workspace:
#    
#    
#    "C:\Program Files\FME2016_1\fme.exe" F:\Bewoning\FME_BEWONING\FME_BEW_BASISDATA_2015\fme\BATCH_BEW.fmw
#          --Toestand "20160101"
#          --GeolocatorRequestURL ""
#          --municipality ""
#          --language "nl"
#    
#    
#!   FME_REPROJECTION_ENGINE="FME"
#!   SOURCE="NONE"
#!   BEGIN_TCL=""
#!   PYTHON_COMPATIBILITY="27"
#!   DESCRIPTION="&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&#10;    &lt;span style=&quot; font-family:&apos;Calibri,sans-serif&apos;; font-size:11pt;&quot;&gt;Gebruik deze workspace om alle processen (000-005) van het dataproces Basisdata Bewoning na elkaar te laten lopen. &lt;/span&gt;&#10;&lt;/p&gt;&#10;"
#!   LOG_FILE=""
#!   DOC_TOP_LEFT="674.298 -1428.14"
#!   FME_BUILD_NUM="16609"
#!   FME_SERVER_SERVICES=""
#!   FME_STROKE_MAX_DEVIATION="0"
#!   DOC_EXTENTS="6840.69 1128.29"
#!   PASSWORD=""
#!   FME_IMPLICIT_CSMAP_REPROJECTION_MODE="Auto"
#!   SHOW_INFO_NODES="true"
#!   MAX_LOG_FEATURES="200"
#!   CATEGORY=""
#!   SHOW_ANNOTATIONS="true"
#!   EXPLICIT_BOOKMARK_ORDER="false"
#!   END_TCL=""
#!   VIEW_POSITION="747.078 820.321"
#!   LEGAL_TERMS_CONDITIONS="&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&#10;    &lt;br/&gt;&#10;&lt;/p&gt;&#10;"
#!   HISTORY="2016-10-06,Jonas&lt;space&gt;Verstraete,Initial&lt;space&gt;version,2016-10-21,Jonas&lt;space&gt;Verstraete,Update&lt;space&gt;new&lt;space&gt;cadastre&lt;space&gt;data&lt;space&gt;structure"
#!   WARN_INVALID_XFORM_PARAM="Yes"
#!   MULTI_WRITER_DATASET_ORDER="BY_ID"
#!   WORKSPACE_VERSION="1"
#!   DESTINATION_ROUTING_FILE=""
#!   ATTR_TYPE_ENCODING="SDF"
#!   SOURCE_ROUTING_FILE=""
#!   ZOOM_SCALE="64"
#!   BEGIN_PYTHON=""
#!   TERMINATE_REJECTED="YES"
#!   LAST_SAVE_DATE="2016-10-27T12:34:32"
#!   END_PYTHON=""
#!   FME_DOCUMENT_PRIORGUID="2e65af18-a4d1-46f2-83fb-ad1f39223e6e,533f932a-208b-4e69-98f1-48ddf0679449,2ae4649c-e636-4a39-af1e-6325fc241c14,0ff09a72-c8d8-4fbb-89f6-a577c89ad758,f1d7260e-fa1a-4dc4-9444-a1b2bc6d26bc,e49796e7-4de5-4976-b0db-f57931c8ad36,6cd8d300-cd0b-4c2f-8285-7c7222924ba8,b22b7901-96bf-44e0-9696-d7946efa9262,236da589-d932-4bec-9249-d3f369259262,58b6feec-156f-4730-a46a-fb50bbafa6b4"
#!   USAGE="&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&#10;    &lt;br/&gt;&#10;&lt;/p&gt;&#10;"
#!   LAST_SAVE_BUILD="FME(R) 2016.1.1.0 (20160722 - Build 16609 - WIN64)"
#!   REQUIREMENTS_KEYWORD="none"
#!   REDIRECT_TERMINATORS="NONE"
#!   IGNORE_READER_FAILURE="No"
#!   FME_DOCUMENT_GUID="f7b99488-95bc-4d23-bf8b-831dbf0caaf7"
#!   LOG_MAX_RECORDED_FEATURES="200"
#!   DESTINATION="NONE"
#!   REQUIREMENTS="&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&#10;    &lt;br/&gt;&#10;&lt;/p&gt;&#10;"
#!   FME_GEOMETRY_HANDLING="Enhanced"
#!   TITLE="BATCH_BEW"
#! >
#! <DATASETS>
#! </DATASETS>
#! <DATA_TYPES>
#! </DATA_TYPES>
#! <GEOM_TYPES>
#! </GEOM_TYPES>
#! <FEATURE_TYPES>
#! </FEATURE_TYPES>
#! <FMESERVER>
#! </FMESERVER>
#! <GLOBAL_PARAMETERS>
#! <GLOBAL_PARAMETER
#!   GUI_LINE="GUI OPTIONAL TEXT_EDIT_OR_NUM_OR_ATTR Toestand Toestand (%Y%m%d):"
#!   DEFAULT_VALUE="20160101"
#!   IS_STAND_ALONE="false"
#! />
#! <GLOBAL_PARAMETER
#!   GUI_LINE="GUI OPTIONAL TEXT_EDIT_OR_NUM_MULTI_FEATURE_OR_ATTR GeolocatorRequestURL &quot; &quot; Attribute Value:"
#!   DEFAULT_VALUE=""
#!   IS_STAND_ALONE="false"
#! />
#! <GLOBAL_PARAMETER
#!   GUI_LINE="GUI OPTIONAL TEXT_EDIT_OR_NUM_OR_ATTR municipality Municipality:"
#!   DEFAULT_VALUE=""
#!   IS_STAND_ALONE="false"
#! />
#! <GLOBAL_PARAMETER
#!   GUI_LINE="GUI OPTIONAL CHOICE_OR_ATTR language fr%nl Municipality language:"
#!   DEFAULT_VALUE="nl"
#!   IS_STAND_ALONE="false"
#! />
#! </GLOBAL_PARAMETERS>
#! <COMMENTS>
#! <COMMENT
#!   IDENTIFIER="50"
#!   COMMENT_VALUE="&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;&#10;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&#10;p, li { white-space: pre-wrap; }&#10;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;MS Shell Dlg 2&apos;; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;&#10;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;BEW_BATCH.fmw&lt;/p&gt;&#10;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Calibri,sans-serif&apos;; font-size:11pt; font-weight:600;&quot;&gt;Gebruik deze workspace om alle processen &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Calibri,sans-serif&apos;; font-size:11pt; font-weight:600;&quot;&gt;(000-005) &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Calibri,sans-serif&apos;; font-size:11pt; font-weight:600;&quot;&gt;van het dataproces Basisdata Bewoning na elkaar te laten lopen. &lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
#!   POSITION="1362.51 -299.847"
#!   TOP_LEFT="1362.51 -299.847"
#!   BOTTOM_RIGHT="3896.91 -442.348"
#!   BOUNDING_RECT="1362.51 -299.847 2534.4 142.501"
#!   ORDER="5e+14"
#!   FOLLOW_ANCHOR="true"
#!   INFO_NODE="false"
#!   COLOUR="1,1,0.784314,0.192157"
#!   SIZE_POLICY="10"
#!   COMMENT_TYPE="REGULAR"
#!   ANCHORED_NODE="0"
#! />
#! </COMMENTS>
#! <CONSTANTS>
#! </CONSTANTS>
#! <BOOKMARKS>
#! <BOOKMARK
#!   IDENTIFIER="6"
#!   NAME="000_BEW_BevRegbasisdata"
#!   DESCRIPTION="&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;&#10;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&#10;p, li { white-space: pre-wrap; }&#10;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;MS Shell Dlg 2&apos;; font-size:8.25pt; font-weight:400; font-style:normal;&quot;&gt;&#10;&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
#!   TOP_LEFT="1362.51 -767.3"
#!   BOTTOM_RIGHT="2068.77 -1428.14"
#!   BOUNDING_RECT="1362.51 -767.3 706.257 660.839"
#!   STICKY="true"
#!   COLOUR="0.564706,0.831373,0.0901961"
#!   CONTENTS="4 5 2 "
#! />
#! <BOOKMARK
#!   IDENTIFIER="10"
#!   NAME="000_BEW_CRABbasisdata"
#!   DESCRIPTION="&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;&#10;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&#10;p, li { white-space: pre-wrap; }&#10;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;MS Shell Dlg 2&apos;; font-size:8.25pt; font-weight:400; font-style:normal;&quot;&gt;&#10;&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
#!   TOP_LEFT="2125.02 -767.3"
#!   BOTTOM_RIGHT="2831.28 -1428.14"
#!   BOUNDING_RECT="2125.02 -767.3 706.257 660.839"
#!   STICKY="true"
#!   COLOUR="0.564706,0.831373,0.0901961"
#!   CONTENTS="7 9 8 "
#! />
#! <BOOKMARK
#!   IDENTIFIER="15"
#!   NAME="000_BEW_KADbasisdata"
#!   DESCRIPTION="&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;&#10;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&#10;p, li { white-space: pre-wrap; }&#10;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;MS Shell Dlg 2&apos;; font-size:8.25pt; font-weight:400; font-style:normal;&quot;&gt;&#10;&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
#!   TOP_LEFT="2893.78 -767.3"
#!   BOTTOM_RIGHT="3600.04 -1428.14"
#!   BOUNDING_RECT="2893.78 -767.3 706.257 660.839"
#!   STICKY="true"
#!   COLOUR="0.564706,0.831373,0.0901961"
#!   CONTENTS="14 13 12 "
#! />
#! <BOOKMARK
#!   IDENTIFIER="20"
#!   NAME="001_BEW_BevolkingsReg_CRAB"
#!   DESCRIPTION="&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;&#10;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&#10;p, li { white-space: pre-wrap; }&#10;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;MS Shell Dlg 2&apos;; font-size:8.25pt; font-weight:400; font-style:normal;&quot;&gt;&#10;&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
#!   TOP_LEFT="3665.66 -767.3"
#!   BOTTOM_RIGHT="4371.92 -1428.14"
#!   BOUNDING_RECT="3665.66 -767.3 706.257 660.839"
#!   STICKY="true"
#!   COLOUR="0.564706,0.831373,0.0901961"
#!   CONTENTS="19 17 18 "
#! />
#! <BOOKMARK
#!   IDENTIFIER="25"
#!   NAME="002_BEW_KAD_CRAB_MATCH"
#!   DESCRIPTION="&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;&#10;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&#10;p, li { white-space: pre-wrap; }&#10;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;MS Shell Dlg 2&apos;; font-size:8.25pt; font-weight:400; font-style:normal;&quot;&gt;&#10;&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
#!   TOP_LEFT="4440.67 -762.718"
#!   BOTTOM_RIGHT="5146.93 -1423.56"
#!   BOUNDING_RECT="4440.67 -762.718 706.257 660.839"
#!   STICKY="true"
#!   COLOUR="0.564706,0.831373,0.0901961"
#!   CONTENTS="24 23 22 "
#! />
#! <BOOKMARK
#!   IDENTIFIER="30"
#!   NAME="003_BEW_Wooneenheden"
#!   DESCRIPTION="&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;&#10;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&#10;p, li { white-space: pre-wrap; }&#10;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;MS Shell Dlg 2&apos;; font-size:8.25pt; font-weight:400; font-style:normal;&quot;&gt;&#10;&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
#!   TOP_LEFT="5210.2 -767.3"
#!   BOTTOM_RIGHT="5916.46 -1428.14"
#!   BOUNDING_RECT="5210.2 -767.3 706.257 660.839"
#!   STICKY="true"
#!   COLOUR="0.564706,0.831373,0.0901961"
#!   CONTENTS="29 28 27 "
#! />
#! <BOOKMARK
#!   IDENTIFIER="35"
#!   NAME="004_BEW_Eigenaars"
#!   DESCRIPTION="&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;&#10;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&#10;p, li { white-space: pre-wrap; }&#10;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;MS Shell Dlg 2&apos;; font-size:8.25pt; font-weight:400; font-style:normal;&quot;&gt;&#10;&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
#!   TOP_LEFT="5993.39 -767.3"
#!   BOTTOM_RIGHT="6699.65 -1428.14"
#!   BOUNDING_RECT="5993.39 -767.3 706.257 660.839"
#!   STICKY="true"
#!   COLOUR="0.564706,0.831373,0.0901961"
#!   CONTENTS="32 34 33 "
#! />
#! <BOOKMARK
#!   IDENTIFIER="45"
#!   NAME="005_BEW_CopyToOutput"
#!   DESCRIPTION="&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;&#10;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&#10;p, li { white-space: pre-wrap; }&#10;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;MS Shell Dlg 2&apos;; font-size:8.25pt; font-weight:400; font-style:normal;&quot;&gt;&#10;&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
#!   TOP_LEFT="6785.61 -767.3"
#!   BOTTOM_RIGHT="7491.87 -1428.14"
#!   BOUNDING_RECT="6785.61 -767.3 706.257 660.839"
#!   STICKY="true"
#!   COLOUR="0.564706,0.831373,0.0901961"
#!   CONTENTS="42 44 43 "
#! />
#! </BOOKMARKS>
#! <TRANSFORMERS>
#! <TRANSFORMER
#!   IDENTIFIER="1"
#!   TYPE="Creator"
#!   VERSION="5"
#!   POSITION="674.298 -910.176"
#!   BOUNDING_RECT="674.298 -910.176 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="false"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <OUTPUT_FEAT NAME="CREATED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="COORDSYS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="GEOM" PARM_VALUE="&lt;lt&gt;?xml&lt;space&gt;version=&lt;quote&gt;1.0&lt;quote&gt;&lt;space&gt;encoding=&lt;quote&gt;US_ASCII&lt;quote&gt;&lt;space&gt;standalone=&lt;quote&gt;no&lt;quote&gt;&lt;space&gt;?&lt;gt&gt;&lt;lt&gt;geometry&lt;space&gt;dimension=&lt;quote&gt;2&lt;quote&gt;&lt;gt&gt;&lt;lt&gt;null&lt;solidus&gt;&lt;gt&gt;&lt;lt&gt;&lt;solidus&gt;geometry&lt;gt&gt;"/>
#!     <XFORM_PARM PARM_NAME="ATEND" PARM_VALUE="no"/>
#!     <XFORM_PARM PARM_NAME="GEOMTYPE" PARM_VALUE="Geometry Object"/>
#!     <XFORM_PARM PARM_NAME="COORDS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="CRE_ATTR" PARM_VALUE="_creation_instance"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="Creator"/>
#!     <XFORM_PARM PARM_NAME="NUM" PARM_VALUE="1"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="2"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="1495.89 -910.176"
#!   BOUNDING_RECT="1495.89 -910.176 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="000_BEW_BevRegbasisdata.fmw"/>
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_000"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="DestDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000&lt;backslash&gt;000_BevReg.ffs,SourceDataset_CSV_4,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;BevReg_extr.csv,SourceDataset_CSV,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;CRAB_RijksregisterStraat.csv"/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="FILENAME,MULTIFILE,MULTIFILE"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="4"
#!   TYPE="Inspector"
#!   VERSION="3"
#!   POSITION="1495.89 -1260.18"
#!   BOUNDING_RECT="1495.89 -1260.18 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="false"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_Failed"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="7"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="2258.4 -910.176"
#!   BOUNDING_RECT="2258.4 -910.176 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="000_BEW_CRABbasisdata.fmw"/>
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_2"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="Toestand,$(Toestand),DestDataset_SHAPE,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000,DestDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000&lt;backslash&gt;000_CRAB_alladr.ffs,SourceDataset_CSV_10,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;huisnummer.csv,SourceDataset_CSV,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;subadres.csv,SourceDataset_CSV_9,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;adrespositie.csv,SourceDataset_CSV_11,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;straatnaam.csv,SourceDataset_CSV_7,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;postkantoncode.csv"/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="TEXT_EDIT_OR_NUM,DIRNAME,FILENAME,MULTIFILE,MULTIFILE,MULTIFILE,MULTIFILE,MULTIFILE"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="8"
#!   TYPE="Inspector"
#!   VERSION="3"
#!   POSITION="2258.4 -1260.18"
#!   BOUNDING_RECT="2258.4 -1260.18 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="false"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_Failed_2"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="12"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="3027.16 -910.176"
#!   BOUNDING_RECT="3027.16 -910.176 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="000_BEW_KADbasisdata.fmw"/>
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_3"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="DestDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000&lt;backslash&gt;000_KAD.ffs,SourceDataset_SHAPE_4,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;B_CaPa.shp,MINX,,MINY,,MAXX,,MAXY,,DestDataset_CSV,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000,SourceDataset_CSV,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;KADnature_codelist.csv,SourceDataset_CSV_4,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;KAD_owner.csv,SourceDataset_CSV_8,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;KAD_parcel.csv"/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="FILENAME,MULTIFILE,FLOAT,FLOAT,FLOAT,FLOAT,DIRNAME,MULTIFILE,MULTIFILE,MULTIFILE"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="13"
#!   TYPE="Inspector"
#!   VERSION="3"
#!   POSITION="3027.16 -1260.18"
#!   BOUNDING_RECT="3027.16 -1260.18 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="false"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_Failed_3"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="17"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="3799.04 -910.176"
#!   BOUNDING_RECT="3799.04 -910.176 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="001_BEW_BevolkingsReg_CRAB.fmw"/>
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_4"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="DestDataset_SHAPE,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;001,DestDataset_CSV,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;001,SourceDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000&lt;backslash&gt;000_CRAB_alladr.ffs,SourceDataset_FFS_4,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000&lt;backslash&gt;000_BevReg.ffs,DestDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;001&lt;backslash&gt;001_BevReg_CRAB.ffs,DestDataset_FFS_2,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;001&lt;backslash&gt;001_BevReg_adr_notCRAB.ffs,MINX,,MINY,,MAXX,,MAXY,,GeolocatorRequestURL,$(GeolocatorRequestURL)"/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="DIRNAME,DIRNAME,MULTIFILE,MULTIFILE,FILENAME,FILENAME,FLOAT,FLOAT,FLOAT,FLOAT,TEXT_EDIT_OR_NUM_MULTI_FEATURE"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="18"
#!   TYPE="Inspector"
#!   VERSION="3"
#!   POSITION="3799.04 -1260.18"
#!   BOUNDING_RECT="3799.04 -1260.18 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="false"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_Failed_4"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="22"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="4574.05 -905.594"
#!   BOUNDING_RECT="4574.05 -905.594 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="002_BEW_KAD_CRAB_MATCH.fmw"/>
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_5"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_SHAPE_5,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;CRAB_Percelen_CenterPoints.shp,DestDataset_CSV_3,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;002,SourceDataset_SHAPE_4,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;B_CaPa.shp,MINX,,MINY,,MAXX,,MAXY,,SourceDataset_FFS_6,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000&lt;backslash&gt;000_CRAB_alladr.ffs,DestDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;002&lt;backslash&gt;002_CRAB_alladr_capakey.ffs,DestDataset_ESRISHAPE,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;002,SourceDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;001&lt;backslash&gt;001_BevReg_adr_notCRAB.ffs,SourceDataset_FFS_7,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000&lt;backslash&gt;000_KAD.ffs"/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,DIRNAME,MULTIFILE,FLOAT,FLOAT,FLOAT,FLOAT,MULTIFILE,FILENAME,DIRNAME,MULTIFILE,MULTIFILE"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="23"
#!   TYPE="Inspector"
#!   VERSION="3"
#!   POSITION="4574.05 -1255.6"
#!   BOUNDING_RECT="4574.05 -1255.6 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="false"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_Failed_5"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="27"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="5343.58 -910.176"
#!   BOUNDING_RECT="5343.58 -910.176 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="003_BEW_Wooneenheden.fmw"/>
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_6"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="MINX,,MINY,,MAXX,,MAXY,,SourceDataset_FFS_4,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;002&lt;backslash&gt;002_CRAB_alladr_capakey.ffs,SourceDataset_FFS_5,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;001&lt;backslash&gt;001_BevReg_CRAB.ffs,DestDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;003&lt;backslash&gt;003_Huishoudens.ffs,DestDataset_FFS_2,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;003&lt;backslash&gt;003_Gebouweenheden_Adressen.ffs,DestDataset_FFS_3,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;003&lt;backslash&gt;003_KADparcel_Gebouweenheden.ffs,DestDataset_ESRISHAPE,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;003,SourceDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000&lt;backslash&gt;000_KAD.ffs,SourceDataset_Handelspanden,..&lt;backslash&gt;data&lt;backslash&gt;input&lt;backslash&gt;Handelspanden.shp"/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="FLOAT,FLOAT,FLOAT,FLOAT,MULTIFILE,MULTIFILE,FILENAME,FILENAME,FILENAME,DIRNAME,MULTIFILE,MULTIFILE"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="28"
#!   TYPE="Inspector"
#!   VERSION="3"
#!   POSITION="5343.58 -1260.18"
#!   BOUNDING_RECT="5343.58 -1260.18 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="false"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_Failed_6"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="32"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="6126.77 -910.176"
#!   BOUNDING_RECT="6126.77 -910.176 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="004_BEW_Eigenaars.fmw"/>
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_7"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_FFS_9,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;001&lt;backslash&gt;001_BevReg_adr_notCRAB.ffs,MINX,,MINY,,MAXX,,MAXY,,SourceDataset_FFS_14,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;001&lt;backslash&gt;001_BevReg_CRAB.ffs,municipality,$(municipality),language,$(language),SourceDataset_FFS_13,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000&lt;backslash&gt;000_CRAB_alladr.ffs,DestDataset_FFS_2,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;004&lt;backslash&gt;004_KAD_owner.ffs,DestDataset_FFS_3,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;004&lt;backslash&gt;004_Gebouweenheden_Adressen.ffs,SourceDataset_FFS_6,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;003&lt;backslash&gt;003_Gebouweenheden_Adressen.ffs,DestDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;004&lt;backslash&gt;004_KAD_percelen.ffs,SourceDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;003&lt;backslash&gt;003_KADparcel_Gebouweenheden.ffs,SourceDataset_FFS_12,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000&lt;backslash&gt;000_KAD.ffs"/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FLOAT,FLOAT,FLOAT,FLOAT,MULTIFILE,TEXT_EDIT_OR_NUM,CHOICE,MULTIFILE,FILENAME,FILENAME,MULTIFILE,FILENAME,MULTIFILE,MULTIFILE"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="33"
#!   TYPE="Inspector"
#!   VERSION="3"
#!   POSITION="6126.77 -1260.18"
#!   BOUNDING_RECT="6126.77 -1260.18 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="false"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_Failed_7"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="42"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="6918.99 -910.176"
#!   BOUNDING_RECT="6918.99 -910.176 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_creation_instance" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="005_BEW_CopyToOutput.fmw"/>
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_8"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;001&lt;backslash&gt;001_BevReg_CRAB.ffs,SourceDataset_FFS_9,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;003&lt;backslash&gt;003_Huishoudens.ffs,SourceDataset_FFS_13,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;002&lt;backslash&gt;002_CRAB_alladr_capakey.ffs,DestDataset_FFS,..&lt;backslash&gt;data&lt;backslash&gt;output&lt;backslash&gt;BEW_Inwoners.ffs,DestDataset_ESRISHAPE,..&lt;backslash&gt;data&lt;backslash&gt;output,DestDataset_FFS_2,..&lt;backslash&gt;data&lt;backslash&gt;output&lt;backslash&gt;BEW_Huishoudens.ffs,DestDataset_FFS_3,..&lt;backslash&gt;data&lt;backslash&gt;output&lt;backslash&gt;BEW_Adressen.ffs,DestDataset_FFS_4,..&lt;backslash&gt;data&lt;backslash&gt;output&lt;backslash&gt;BEW_Gebouweenheden_Adressen.ffs,DestDataset_FFS_5,..&lt;backslash&gt;data&lt;backslash&gt;output&lt;backslash&gt;BEW_Percelen.ffs,DestDataset_FFS_6,..&lt;backslash&gt;data&lt;backslash&gt;output&lt;backslash&gt;BEW_Eigendommen.ffs,DestDataset_FFS_11,..&lt;backslash&gt;data&lt;backslash&gt;output&lt;backslash&gt;BEW_Eigenaars.ffs,SourceDataset_FFS_14,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;004&lt;backslash&gt;004_Gebouweenheden_Adressen.ffs,SourceDataset_FFS_10,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;004&lt;backslash&gt;004_KAD_percelen.ffs,SourceDataset_FFS_11,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;000&lt;backslash&gt;000_KAD.ffs,SourceDataset_FFS_8,..&lt;backslash&gt;data&lt;backslash&gt;intermediate&lt;backslash&gt;004&lt;backslash&gt;004_KAD_owner.ffs"/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,MULTIFILE,MULTIFILE,FILENAME,DIRNAME,FILENAME,FILENAME,FILENAME,FILENAME,FILENAME,FILENAME,MULTIFILE,MULTIFILE,MULTIFILE,MULTIFILE"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="43"
#!   TYPE="Inspector"
#!   VERSION="3"
#!   POSITION="6918.99 -1260.18"
#!   BOUNDING_RECT="6918.99 -1260.18 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="false"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_Failed_8"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="47"
#!   TYPE="Inspector"
#!   VERSION="3"
#!   POSITION="7514.99 -910.176"
#!   BOUNDING_RECT="7514.99 -910.176 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="false"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="16609"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="WorkspaceRunner_8_Succeeded"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#! </TRANSFORMER>
#! </TRANSFORMERS>
#! <FEAT_LINKS>
#! <FEAT_LINK
#!   IDENTIFIER="49"
#!   SOURCE_NODE="1"
#!   TARGET_NODE="2"
#!   SOURCE_PORT_DESC="fo 0 CREATED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="11"
#!   SOURCE_NODE="2"
#!   TARGET_NODE="7"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="16"
#!   SOURCE_NODE="7"
#!   TARGET_NODE="12"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="21"
#!   SOURCE_NODE="12"
#!   TARGET_NODE="17"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="26"
#!   SOURCE_NODE="17"
#!   TARGET_NODE="22"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="31"
#!   SOURCE_NODE="22"
#!   TARGET_NODE="27"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="39"
#!   SOURCE_NODE="27"
#!   TARGET_NODE="32"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="46"
#!   SOURCE_NODE="32"
#!   TARGET_NODE="42"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="48"
#!   SOURCE_NODE="42"
#!   TARGET_NODE="47"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="5"
#!   SOURCE_NODE="2"
#!   TARGET_NODE="4"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="9"
#!   SOURCE_NODE="7"
#!   TARGET_NODE="8"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="14"
#!   SOURCE_NODE="12"
#!   TARGET_NODE="13"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="19"
#!   SOURCE_NODE="17"
#!   TARGET_NODE="18"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="24"
#!   SOURCE_NODE="22"
#!   TARGET_NODE="23"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="29"
#!   SOURCE_NODE="27"
#!   TARGET_NODE="28"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="34"
#!   SOURCE_NODE="32"
#!   TARGET_NODE="33"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="44"
#!   SOURCE_NODE="42"
#!   TARGET_NODE="43"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! </FEAT_LINKS>
#! <BREAKPOINTS>
#! </BREAKPOINTS>
#! <ATTR_LINKS>
#! </ATTR_LINKS>
#! <SUBDOCUMENTS>
#! </SUBDOCUMENTS>
#! <LOOKUP_TABLES>
#! </LOOKUP_TABLES>
#! </WORKSPACE>
FME_PYTHON_VERSION 27
DEFAULT_MACRO Toestand 20160101
GUI OPTIONAL TEXT_EDIT_OR_NUM Toestand Toestand (%Y%m%d):
DEFAULT_MACRO GeolocatorRequestURL 
GUI OPTIONAL TEXT_EDIT_OR_NUM_MULTI_FEATURE GeolocatorRequestURL " " Attribute Value:
DEFAULT_MACRO municipality 
GUI OPTIONAL TEXT_EDIT_OR_NUM municipality Municipality:
DEFAULT_MACRO language nl
GUI OPTIONAL CHOICE language fr%nl Municipality language:
#! START_HEADER
#! START_WB_HEADER
READER_TYPE NULL
READER_KEYWORD NULL_SOURCE
NULL_SOURCE_DATASET null

WRITER_TYPE NULL
WRITER_KEYWORD NULL_DEST
NULL_DEST_DATASET null
#! END_WB_HEADER

#! START_WB_HEADER
#! END_WB_HEADER

#! END_HEADER

LOG_FILENAME "$(FME_MF_DIR)BATCH_BEW.log"
LOG_APPEND NO
LOG_MAX_FEATURES 200
LOG_MAX_RECORDED_FEATURES 200
FME_REPROJECTION_ENGINE FME
FME_IMPLICIT_CSMAP_REPROJECTION_MODE Auto
FME_GEOMETRY_HANDLING Enhanced
FME_STROKE_MAX_DEVIATION 0
MAPPING_FILE_ID BATCH_BEW
LOG_FILTER_MASK -1
# -------------------------------------------------------------------------

MULTI_READER_CONTINUE_ON_READER_FAILURE No

# -------------------------------------------------------------------------

MACRO WORKSPACE_NAME BATCH_BEW
MACRO FME_VIEWER_APP fmedatainspector
# -------------------------------------------------------------------------

INCLUDE [ if {[info exists env(FME_TEMP)] && [file isdirectory $env(FME_TEMP)]} {set gVisualizerTemp $env(FME_TEMP)}  elseif {[info exists env(TEMP)] && [file isdirectory $env(TEMP)]}  {set gVisualizerTemp $env(TEMP)}  elseif { $tcl_platform(platform) == "unix" } {set gVisualizerTemp "/tmp"} else {set gVisualizerTemp c:};  regsub -all {[ ,&]} {$(WORKSPACE_NAME)} {_} wsname; set gVisualizerTemp $gVisualizerTemp/${wsname}_[clock format [clock seconds] -format %H%M%S];  puts "MACRO WORKSPACE_TEMP_DIR $gVisualizerTemp"; 
MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/inspector.ffs
MACRO VISUALIZER_SCHEMA_FILE $(WORKSPACE_TEMP_DIR)/inspector.fsc
MACRO VISUALIZER_CREATE_SPATIAL_INDEX YES
DEFAULT_MACRO WB_CURRENT_CONTEXT
# -------------------------------------------------------------------------

Tcl2 proc Creator_CoordSysRemover {} {   global FME_CoordSys;   set FME_CoordSys {}; }
MACRO Creator_XML     NOT_ACTIVATED
MACRO Creator_CLASSIC NOT_ACTIVATED
MACRO Creator_2D3D    2D_GEOMETRY
MACRO Creator_COORDS  <Unused>
INCLUDE [ if { {Geometry Object} == {Geometry Object} } {            puts {MACRO Creator_XML *} } ]
INCLUDE [ if { {Geometry Object} == {2D Coordinate List} } {            puts {MACRO Creator_2D3D 2D_GEOMETRY};            puts {MACRO Creator_CLASSIC *} } ]
INCLUDE [ if { {Geometry Object} == {3D Coordinate List} } {            puts {MACRO Creator_2D3D 3D_GEOMETRY};            puts {MACRO Creator_CLASSIC *} } ]
INCLUDE [ if { {Geometry Object} == {2D Min/Max Box} } {            set comment {                We need to turn the COORDS which are                    minX minY maxX maxY                into a full polygon list of coordinates            };            set splitCoords [split [string trim {<Unused>}]];            if { [llength $splitCoords] > 4} {               set trimmedCoords {};               foreach item $splitCoords { if { $item != {} } {lappend trimmedCoords $item} };               set splitCoords $trimmedCoords;            };            if { [llength $splitCoords] != 4 } {                error {Creator: Coordinate list is expected to be a space delimited list of four numbers as 'minx miny maxx maxy' - `<Unused>' is invalid};            };            set minX [lindex $splitCoords 0];            set minY [lindex $splitCoords 1];            set maxX [lindex $splitCoords 2];            set maxY [lindex $splitCoords 3];            puts "MACRO Creator_COORDS $minX $minY $minX $maxY $maxX $maxY $maxX $minY $minX $minY";            puts {MACRO Creator_2D3D 2D_GEOMETRY};            puts {MACRO Creator_CLASSIC *} } ]
FACTORY_DEF $(Creator_XML) CreationFactory    FACTORY_NAME Creator_XML_Creator    CREATE_AT_END no    OUTPUT FEATURE_TYPE _____CREATED______        @Geometry(FROM_ENCODED_STRING,<lt>?xml<space>version=<quote>1.0<quote><space>encoding=<quote>US_ASCII<quote><space>standalone=<quote>no<quote><space>?<gt><lt>geometry<space>dimension=<quote>2<quote><gt><lt>null<solidus><gt><lt><solidus>geometry<gt>)
FACTORY_DEF $(Creator_CLASSIC) CreationFactory    FACTORY_NAME Creator_CLASSIC_Creator    $(Creator_2D3D) $(Creator_COORDS)    CREATE_AT_END no    OUTPUT FEATURE_TYPE _____CREATED______
FACTORY_DEF * TeeFactory    FACTORY_NAME Creator_Cloner    INPUT FEATURE_TYPE _____CREATED______    NUMBER_OF_COPIES 1    COPY_NUMBER_ATTRIBUTE "_creation_instance"    OUTPUT FEATURE_TYPE Creator_CREATED        @Tcl2(Creator_CoordSysRemover)        @CoordSys()        fme_feature_type Creator

FACTORY_DEF * BranchingFactory   FACTORY_NAME "Creator_CREATED Brancher -1 49"   INPUT FEATURE_TYPE Creator_CREATED   TARGET_FACTORY "$(WB_CURRENT_CONTEXT)_CREATOR_BRANCH_TARGET"   OUTPUT PASSED FEATURE_TYPE *     @RemoveAttributes("Creator_CREATED Brancher -1 49".BranchingFactory.Count)
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory   FACTORY_NAME "$(WB_CURRENT_CONTEXT)_CREATOR_BRANCH_TARGET"   INPUT FEATURE_TYPE *  OUTPUT FEATURE_TYPE *
# -------------------------------------------------------------------------

# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)

# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)

Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {FILENAME,MULTIFILE,MULTIFILE} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentToLogs \"<$::null_device\";        FME_LogMessage fme_inform \"WorkspaceRunner_000: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"WorkspaceRunner_000: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat WorkspaceRunner_000: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"WorkspaceRunner_000: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_process_count;       incr WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"WorkspaceRunner_000: Successfully initiated run of workspace $workspaceFile\";           global WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_all_processes;           lappend WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_all_processes $msg;       } else {           FME_LogMessage fme_inform \"WorkspaceRunner_000: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_000_ExecutorAndRouter    INPUT  FEATURE_TYPE Creator_CREATED    TEST @Tcl2("WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_runner {(DestDataset_FFS,..\data\intermediate\000\000_BevReg.ffs,SourceDataset_CSV_4,..\data\input\BevReg_extr.csv,SourceDataset_CSV,..\data\input\CRAB_RijksregisterStraat.csv)} {000_BEW_BevRegbasisdata.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_000_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_000_FAILED
Tcl2 proc WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_summarizer { } {     global WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_process_count 0;     FME_SetAttribute _proc_count [set WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_process_count];     global WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_all_processes;     if {[info exists WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_all_processes]} {         set index 0;         foreach pid [set WorkspaceRunner_000_e2ecf7ee_6af8_4f2f_8560_d65d21074c900_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME WorkspaceRunner_000_SummaryMaker    CREATE_AT_END yes

# -------------------------------------------------------------------------

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {WorkspaceRunner_Failed} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME WorkspaceRunner_Failed_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_FeatureDirector    INPUT  FEATURE_TYPE WorkspaceRunner_000_FAILED    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed___FeatureDirector1    INPUT FEATURE_TYPE WorkspaceRunner_Failed___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_VectorSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc WorkspaceRunner_Failed_943ffe91_234d_41c4_83c0_271eebfbd2ea0_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed___PointCloudThinner    INPUT FEATURE_TYPE WorkspaceRunner_Failed___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_943ffe91_234d_41c4_83c0_271eebfbd2ea0_thinPointCloud")
Tcl2 proc WorkspaceRunner_Failed_943ffe91_234d_41c4_83c0_271eebfbd2ea0_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_RasterSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_943ffe91_234d_41c4_83c0_271eebfbd2ea0_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# WorkspaceRunner_Failed_943ffe91_234d_41c4_83c0_271eebfbd2ea0_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO WorkspaceRunner_Failed_943ffe91_234d_41c4_83c0_271eebfbd2ea0_VIS_FEAT_TYPE WorkspaceRunner_Failed$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME WorkspaceRunner_Failed_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(WorkspaceRunner_Failed_943ffe91_234d_41c4_83c0_271eebfbd2ea0_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA _creation_instance,varchar<openparen>255<closeparen>,_failure_message,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)

# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)

Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {TEXT_EDIT_OR_NUM,DIRNAME,FILENAME,MULTIFILE,MULTIFILE,MULTIFILE,MULTIFILE,MULTIFILE} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentToLogs \"<$::null_device\";        FME_LogMessage fme_inform \"WorkspaceRunner_2: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"WorkspaceRunner_2: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat WorkspaceRunner_2: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"WorkspaceRunner_2: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_process_count;       incr WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"WorkspaceRunner_2: Successfully initiated run of workspace $workspaceFile\";           global WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_all_processes;           lappend WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_all_processes $msg;       } else {           FME_LogMessage fme_inform \"WorkspaceRunner_2: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_2_ExecutorAndRouter    INPUT  FEATURE_TYPE WorkspaceRunner_000_SUCCEEDED    TEST @Tcl2("WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_runner {(Toestand,@EvaluateExpression(FDIV,STRING_ENCODED,$(Toestand),WorkspaceRunner_2),DestDataset_SHAPE,..\data\intermediate\000,DestDataset_FFS,..\data\intermediate\000\000_CRAB_alladr.ffs,SourceDataset_CSV_10,..\data\input\huisnummer.csv,SourceDataset_CSV,..\data\input\subadres.csv,SourceDataset_CSV_9,..\data\input\adrespositie.csv,SourceDataset_CSV_11,..\data\input\straatnaam.csv,SourceDataset_CSV_7,..\data\input\postkantoncode.csv)} {000_BEW_CRABbasisdata.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_2_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_2_FAILED
Tcl2 proc WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_summarizer { } {     global WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_process_count 0;     FME_SetAttribute _proc_count [set WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_process_count];     global WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_all_processes;     if {[info exists WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_all_processes]} {         set index 0;         foreach pid [set WorkspaceRunner_2_d92f545f_1529_4a3c_a16d_ac962dc2be860_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME WorkspaceRunner_2_SummaryMaker    CREATE_AT_END yes

# -------------------------------------------------------------------------

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {WorkspaceRunner_Failed_2} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME WorkspaceRunner_Failed_2_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_2_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_2_FeatureDirector    INPUT  FEATURE_TYPE WorkspaceRunner_2_FAILED    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_2___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_2___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_2___FeatureDirector1    INPUT FEATURE_TYPE WorkspaceRunner_Failed_2___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_2___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_2___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_2_VectorSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_2___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc WorkspaceRunner_Failed_2_5b3946c7_01cd_486e_93e6_8c5b4a245dd50_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_2___PointCloudThinner    INPUT FEATURE_TYPE WorkspaceRunner_Failed_2___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_2_5b3946c7_01cd_486e_93e6_8c5b4a245dd50_thinPointCloud")
Tcl2 proc WorkspaceRunner_Failed_2_5b3946c7_01cd_486e_93e6_8c5b4a245dd50_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_2_RasterSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_2___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_2_5b3946c7_01cd_486e_93e6_8c5b4a245dd50_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# WorkspaceRunner_Failed_2_5b3946c7_01cd_486e_93e6_8c5b4a245dd50_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO WorkspaceRunner_Failed_2_5b3946c7_01cd_486e_93e6_8c5b4a245dd50_VIS_FEAT_TYPE WorkspaceRunner_Failed_2$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME WorkspaceRunner_Failed_2_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(WorkspaceRunner_Failed_2_5b3946c7_01cd_486e_93e6_8c5b4a245dd50_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA _creation_instance,varchar<openparen>255<closeparen>,_failure_message,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)

# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)

Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {FILENAME,MULTIFILE,FLOAT,FLOAT,FLOAT,FLOAT,DIRNAME,MULTIFILE,MULTIFILE,MULTIFILE} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentToLogs \"<$::null_device\";        FME_LogMessage fme_inform \"WorkspaceRunner_3: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"WorkspaceRunner_3: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat WorkspaceRunner_3: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"WorkspaceRunner_3: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_process_count;       incr WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"WorkspaceRunner_3: Successfully initiated run of workspace $workspaceFile\";           global WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_all_processes;           lappend WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_all_processes $msg;       } else {           FME_LogMessage fme_inform \"WorkspaceRunner_3: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_3_ExecutorAndRouter    INPUT  FEATURE_TYPE WorkspaceRunner_2_SUCCEEDED    TEST @Tcl2("WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_runner {(DestDataset_FFS,..\data\intermediate\000\000_KAD.ffs,SourceDataset_SHAPE_4,..\data\input\B_CaPa.shp,MINX,,MINY,,MAXX,,MAXY,,DestDataset_CSV,..\data\intermediate\000,SourceDataset_CSV,..\data\input\KADnature_codelist.csv,SourceDataset_CSV_4,..\data\input\KAD_owner.csv,SourceDataset_CSV_8,..\data\input\KAD_parcel.csv)} {000_BEW_KADbasisdata.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_3_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_3_FAILED
Tcl2 proc WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_summarizer { } {     global WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_process_count 0;     FME_SetAttribute _proc_count [set WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_process_count];     global WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_all_processes;     if {[info exists WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_all_processes]} {         set index 0;         foreach pid [set WorkspaceRunner_3_e6b0c343_4367_4d95_ba2b_eb845cb5bf1a0_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME WorkspaceRunner_3_SummaryMaker    CREATE_AT_END yes

# -------------------------------------------------------------------------

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {WorkspaceRunner_Failed_3} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME WorkspaceRunner_Failed_3_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_3_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_3_FeatureDirector    INPUT  FEATURE_TYPE WorkspaceRunner_3_FAILED    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_3___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_3___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_3___FeatureDirector1    INPUT FEATURE_TYPE WorkspaceRunner_Failed_3___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_3___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_3___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_3_VectorSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_3___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc WorkspaceRunner_Failed_3_6af55e1d_4455_42d8_9636_e22a3aab816a0_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_3___PointCloudThinner    INPUT FEATURE_TYPE WorkspaceRunner_Failed_3___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_3_6af55e1d_4455_42d8_9636_e22a3aab816a0_thinPointCloud")
Tcl2 proc WorkspaceRunner_Failed_3_6af55e1d_4455_42d8_9636_e22a3aab816a0_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_3_RasterSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_3___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_3_6af55e1d_4455_42d8_9636_e22a3aab816a0_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# WorkspaceRunner_Failed_3_6af55e1d_4455_42d8_9636_e22a3aab816a0_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO WorkspaceRunner_Failed_3_6af55e1d_4455_42d8_9636_e22a3aab816a0_VIS_FEAT_TYPE WorkspaceRunner_Failed_3$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME WorkspaceRunner_Failed_3_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(WorkspaceRunner_Failed_3_6af55e1d_4455_42d8_9636_e22a3aab816a0_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA _creation_instance,varchar<openparen>255<closeparen>,_failure_message,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)

# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)

Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {DIRNAME,DIRNAME,MULTIFILE,MULTIFILE,FILENAME,FILENAME,FLOAT,FLOAT,FLOAT,FLOAT,TEXT_EDIT_OR_NUM_MULTI_FEATURE} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentToLogs \"<$::null_device\";        FME_LogMessage fme_inform \"WorkspaceRunner_4: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"WorkspaceRunner_4: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat WorkspaceRunner_4: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"WorkspaceRunner_4: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_process_count;       incr WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"WorkspaceRunner_4: Successfully initiated run of workspace $workspaceFile\";           global WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_all_processes;           lappend WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_all_processes $msg;       } else {           FME_LogMessage fme_inform \"WorkspaceRunner_4: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_4_ExecutorAndRouter    INPUT  FEATURE_TYPE WorkspaceRunner_3_SUCCEEDED    TEST @Tcl2("WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_runner {(DestDataset_SHAPE,..\data\intermediate\001,DestDataset_CSV,..\data\intermediate\001,SourceDataset_FFS,..\data\intermediate\000\000_CRAB_alladr.ffs,SourceDataset_FFS_4,..\data\intermediate\000\000_BevReg.ffs,DestDataset_FFS,..\data\intermediate\001\001_BevReg_CRAB.ffs,DestDataset_FFS_2,..\data\intermediate\001\001_BevReg_adr_notCRAB.ffs,MINX,,MINY,,MAXX,,MAXY,,GeolocatorRequestURL,@EvaluateExpression(FDIV,STRING_ENCODED,$(GeolocatorRequestURL),WorkspaceRunner_4))} {001_BEW_BevolkingsReg_CRAB.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_4_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_4_FAILED
Tcl2 proc WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_summarizer { } {     global WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_process_count 0;     FME_SetAttribute _proc_count [set WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_process_count];     global WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_all_processes;     if {[info exists WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_all_processes]} {         set index 0;         foreach pid [set WorkspaceRunner_4_ac3234b0_b139_476f_a9e0_86ac858bec270_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME WorkspaceRunner_4_SummaryMaker    CREATE_AT_END yes

# -------------------------------------------------------------------------

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {WorkspaceRunner_Failed_4} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME WorkspaceRunner_Failed_4_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_4_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_4_FeatureDirector    INPUT  FEATURE_TYPE WorkspaceRunner_4_FAILED    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_4___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_4___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_4___FeatureDirector1    INPUT FEATURE_TYPE WorkspaceRunner_Failed_4___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_4___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_4___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_4_VectorSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_4___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc WorkspaceRunner_Failed_4_5ec51142_28c5_4ada_ae95_5f412c7e263a0_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_4___PointCloudThinner    INPUT FEATURE_TYPE WorkspaceRunner_Failed_4___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_4_5ec51142_28c5_4ada_ae95_5f412c7e263a0_thinPointCloud")
Tcl2 proc WorkspaceRunner_Failed_4_5ec51142_28c5_4ada_ae95_5f412c7e263a0_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_4_RasterSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_4___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_4_5ec51142_28c5_4ada_ae95_5f412c7e263a0_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# WorkspaceRunner_Failed_4_5ec51142_28c5_4ada_ae95_5f412c7e263a0_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO WorkspaceRunner_Failed_4_5ec51142_28c5_4ada_ae95_5f412c7e263a0_VIS_FEAT_TYPE WorkspaceRunner_Failed_4$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME WorkspaceRunner_Failed_4_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(WorkspaceRunner_Failed_4_5ec51142_28c5_4ada_ae95_5f412c7e263a0_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA _creation_instance,varchar<openparen>255<closeparen>,_failure_message,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)

# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)

Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,DIRNAME,MULTIFILE,FLOAT,FLOAT,FLOAT,FLOAT,MULTIFILE,FILENAME,DIRNAME,MULTIFILE,MULTIFILE} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentToLogs \"<$::null_device\";        FME_LogMessage fme_inform \"WorkspaceRunner_5: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"WorkspaceRunner_5: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat WorkspaceRunner_5: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"WorkspaceRunner_5: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_process_count;       incr WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"WorkspaceRunner_5: Successfully initiated run of workspace $workspaceFile\";           global WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_all_processes;           lappend WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_all_processes $msg;       } else {           FME_LogMessage fme_inform \"WorkspaceRunner_5: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_5_ExecutorAndRouter    INPUT  FEATURE_TYPE WorkspaceRunner_4_SUCCEEDED    TEST @Tcl2("WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_runner {(SourceDataset_SHAPE_5,..\data\input\CRAB_Percelen_CenterPoints.shp,DestDataset_CSV_3,..\data\intermediate\002,SourceDataset_SHAPE_4,..\data\input\B_CaPa.shp,MINX,,MINY,,MAXX,,MAXY,,SourceDataset_FFS_6,..\data\intermediate\000\000_CRAB_alladr.ffs,DestDataset_FFS,..\data\intermediate\002\002_CRAB_alladr_capakey.ffs,DestDataset_ESRISHAPE,..\data\intermediate\002,SourceDataset_FFS,..\data\intermediate\001\001_BevReg_adr_notCRAB.ffs,SourceDataset_FFS_7,..\data\intermediate\000\000_KAD.ffs)} {002_BEW_KAD_CRAB_MATCH.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_5_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_5_FAILED
Tcl2 proc WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_summarizer { } {     global WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_process_count 0;     FME_SetAttribute _proc_count [set WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_process_count];     global WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_all_processes;     if {[info exists WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_all_processes]} {         set index 0;         foreach pid [set WorkspaceRunner_5_5b1abf8c_3b3b_4efb_938e_df85a58326090_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME WorkspaceRunner_5_SummaryMaker    CREATE_AT_END yes

# -------------------------------------------------------------------------

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {WorkspaceRunner_Failed_5} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME WorkspaceRunner_Failed_5_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_5_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_5_FeatureDirector    INPUT  FEATURE_TYPE WorkspaceRunner_5_FAILED    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_5___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_5___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_5___FeatureDirector1    INPUT FEATURE_TYPE WorkspaceRunner_Failed_5___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_5___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_5___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_5_VectorSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_5___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc WorkspaceRunner_Failed_5_c6136131_8fa2_4cba_9dfc_a3f8441334d70_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_5___PointCloudThinner    INPUT FEATURE_TYPE WorkspaceRunner_Failed_5___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_5_c6136131_8fa2_4cba_9dfc_a3f8441334d70_thinPointCloud")
Tcl2 proc WorkspaceRunner_Failed_5_c6136131_8fa2_4cba_9dfc_a3f8441334d70_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_5_RasterSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_5___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_5_c6136131_8fa2_4cba_9dfc_a3f8441334d70_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# WorkspaceRunner_Failed_5_c6136131_8fa2_4cba_9dfc_a3f8441334d70_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO WorkspaceRunner_Failed_5_c6136131_8fa2_4cba_9dfc_a3f8441334d70_VIS_FEAT_TYPE WorkspaceRunner_Failed_5$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME WorkspaceRunner_Failed_5_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(WorkspaceRunner_Failed_5_c6136131_8fa2_4cba_9dfc_a3f8441334d70_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA _creation_instance,varchar<openparen>255<closeparen>,_failure_message,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)

# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)

Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {FLOAT,FLOAT,FLOAT,FLOAT,MULTIFILE,MULTIFILE,FILENAME,FILENAME,FILENAME,DIRNAME,MULTIFILE,MULTIFILE} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentToLogs \"<$::null_device\";        FME_LogMessage fme_inform \"WorkspaceRunner_6: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"WorkspaceRunner_6: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat WorkspaceRunner_6: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"WorkspaceRunner_6: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_process_count;       incr WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"WorkspaceRunner_6: Successfully initiated run of workspace $workspaceFile\";           global WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_all_processes;           lappend WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_all_processes $msg;       } else {           FME_LogMessage fme_inform \"WorkspaceRunner_6: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_6_ExecutorAndRouter    INPUT  FEATURE_TYPE WorkspaceRunner_5_SUCCEEDED    TEST @Tcl2("WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_runner {(MINX,,MINY,,MAXX,,MAXY,,SourceDataset_FFS_4,..\data\intermediate\002\002_CRAB_alladr_capakey.ffs,SourceDataset_FFS_5,..\data\intermediate\001\001_BevReg_CRAB.ffs,DestDataset_FFS,..\data\intermediate\003\003_Huishoudens.ffs,DestDataset_FFS_2,..\data\intermediate\003\003_Gebouweenheden_Adressen.ffs,DestDataset_FFS_3,..\data\intermediate\003\003_KADparcel_Gebouweenheden.ffs,DestDataset_ESRISHAPE,..\data\intermediate\003,SourceDataset_FFS,..\data\intermediate\000\000_KAD.ffs,SourceDataset_Handelspanden,..\data\input\Handelspanden.shp)} {003_BEW_Wooneenheden.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_6_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_6_FAILED
Tcl2 proc WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_summarizer { } {     global WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_process_count 0;     FME_SetAttribute _proc_count [set WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_process_count];     global WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_all_processes;     if {[info exists WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_all_processes]} {         set index 0;         foreach pid [set WorkspaceRunner_6_4a1a8ede_36c0_4d27_980c_f94dc4df2c910_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME WorkspaceRunner_6_SummaryMaker    CREATE_AT_END yes

# -------------------------------------------------------------------------

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {WorkspaceRunner_Failed_6} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME WorkspaceRunner_Failed_6_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_6_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_6_FeatureDirector    INPUT  FEATURE_TYPE WorkspaceRunner_6_FAILED    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_6___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_6___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_6___FeatureDirector1    INPUT FEATURE_TYPE WorkspaceRunner_Failed_6___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_6___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_6___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_6_VectorSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_6___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc WorkspaceRunner_Failed_6_05e88001_c0b8_40d3_a7cc_ff7e1b65ccef0_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_6___PointCloudThinner    INPUT FEATURE_TYPE WorkspaceRunner_Failed_6___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_6_05e88001_c0b8_40d3_a7cc_ff7e1b65ccef0_thinPointCloud")
Tcl2 proc WorkspaceRunner_Failed_6_05e88001_c0b8_40d3_a7cc_ff7e1b65ccef0_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_6_RasterSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_6___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_6_05e88001_c0b8_40d3_a7cc_ff7e1b65ccef0_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# WorkspaceRunner_Failed_6_05e88001_c0b8_40d3_a7cc_ff7e1b65ccef0_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO WorkspaceRunner_Failed_6_05e88001_c0b8_40d3_a7cc_ff7e1b65ccef0_VIS_FEAT_TYPE WorkspaceRunner_Failed_6$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME WorkspaceRunner_Failed_6_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(WorkspaceRunner_Failed_6_05e88001_c0b8_40d3_a7cc_ff7e1b65ccef0_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA _creation_instance,varchar<openparen>255<closeparen>,_failure_message,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)

# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)

Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FLOAT,FLOAT,FLOAT,FLOAT,MULTIFILE,TEXT_EDIT_OR_NUM,CHOICE,MULTIFILE,FILENAME,FILENAME,MULTIFILE,FILENAME,MULTIFILE,MULTIFILE} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentToLogs \"<$::null_device\";        FME_LogMessage fme_inform \"WorkspaceRunner_7: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"WorkspaceRunner_7: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat WorkspaceRunner_7: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"WorkspaceRunner_7: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_process_count;       incr WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"WorkspaceRunner_7: Successfully initiated run of workspace $workspaceFile\";           global WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_all_processes;           lappend WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_all_processes $msg;       } else {           FME_LogMessage fme_inform \"WorkspaceRunner_7: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_7_ExecutorAndRouter    INPUT  FEATURE_TYPE WorkspaceRunner_6_SUCCEEDED    TEST @Tcl2("WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_runner {(SourceDataset_FFS_9,..\data\intermediate\001\001_BevReg_adr_notCRAB.ffs,MINX,,MINY,,MAXX,,MAXY,,SourceDataset_FFS_14,..\data\intermediate\001\001_BevReg_CRAB.ffs,municipality,@EvaluateExpression(FDIV,STRING_ENCODED,$(municipality),WorkspaceRunner_7),language,@EvaluateExpression(FDIV,STRING,$(language$encode),WorkspaceRunner_7),SourceDataset_FFS_13,..\data\intermediate\000\000_CRAB_alladr.ffs,DestDataset_FFS_2,..\data\intermediate\004\004_KAD_owner.ffs,DestDataset_FFS_3,..\data\intermediate\004\004_Gebouweenheden_Adressen.ffs,SourceDataset_FFS_6,..\data\intermediate\003\003_Gebouweenheden_Adressen.ffs,DestDataset_FFS,..\data\intermediate\004\004_KAD_percelen.ffs,SourceDataset_FFS,..\data\intermediate\003\003_KADparcel_Gebouweenheden.ffs,SourceDataset_FFS_12,..\data\intermediate\000\000_KAD.ffs)} {004_BEW_Eigenaars.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_7_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_7_FAILED
Tcl2 proc WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_summarizer { } {     global WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_process_count 0;     FME_SetAttribute _proc_count [set WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_process_count];     global WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_all_processes;     if {[info exists WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_all_processes]} {         set index 0;         foreach pid [set WorkspaceRunner_7_ac8806e6_c0db_4431_af75_bef266a864590_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME WorkspaceRunner_7_SummaryMaker    CREATE_AT_END yes

# -------------------------------------------------------------------------

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {WorkspaceRunner_Failed_7} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME WorkspaceRunner_Failed_7_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_7_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_7_FeatureDirector    INPUT  FEATURE_TYPE WorkspaceRunner_7_FAILED    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_7___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_7___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_7___FeatureDirector1    INPUT FEATURE_TYPE WorkspaceRunner_Failed_7___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_7___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_7___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_7_VectorSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_7___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc WorkspaceRunner_Failed_7_8c3a90e1_7393_400b_8524_29d89f004c470_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_7___PointCloudThinner    INPUT FEATURE_TYPE WorkspaceRunner_Failed_7___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_7_8c3a90e1_7393_400b_8524_29d89f004c470_thinPointCloud")
Tcl2 proc WorkspaceRunner_Failed_7_8c3a90e1_7393_400b_8524_29d89f004c470_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_7_RasterSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_7___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_7_8c3a90e1_7393_400b_8524_29d89f004c470_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# WorkspaceRunner_Failed_7_8c3a90e1_7393_400b_8524_29d89f004c470_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO WorkspaceRunner_Failed_7_8c3a90e1_7393_400b_8524_29d89f004c470_VIS_FEAT_TYPE WorkspaceRunner_Failed_7$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME WorkspaceRunner_Failed_7_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(WorkspaceRunner_Failed_7_8c3a90e1_7393_400b_8524_29d89f004c470_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA _creation_instance,varchar<openparen>255<closeparen>,_failure_message,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)

# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)

Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,MULTIFILE,MULTIFILE,FILENAME,DIRNAME,FILENAME,FILENAME,FILENAME,FILENAME,FILENAME,FILENAME,MULTIFILE,MULTIFILE,MULTIFILE,MULTIFILE} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentToLogs \"<$::null_device\";        FME_LogMessage fme_inform \"WorkspaceRunner_8: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"WorkspaceRunner_8: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat WorkspaceRunner_8: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"WorkspaceRunner_8: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_process_count;       incr WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"WorkspaceRunner_8: Successfully initiated run of workspace $workspaceFile\";           global WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_all_processes;           lappend WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_all_processes $msg;       } else {           FME_LogMessage fme_inform \"WorkspaceRunner_8: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_8_ExecutorAndRouter    INPUT  FEATURE_TYPE WorkspaceRunner_7_SUCCEEDED    TEST @Tcl2("WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_runner {(SourceDataset_FFS,..\data\intermediate\001\001_BevReg_CRAB.ffs,SourceDataset_FFS_9,..\data\intermediate\003\003_Huishoudens.ffs,SourceDataset_FFS_13,..\data\intermediate\002\002_CRAB_alladr_capakey.ffs,DestDataset_FFS,..\data\output\BEW_Inwoners.ffs,DestDataset_ESRISHAPE,..\data\output,DestDataset_FFS_2,..\data\output\BEW_Huishoudens.ffs,DestDataset_FFS_3,..\data\output\BEW_Adressen.ffs,DestDataset_FFS_4,..\data\output\BEW_Gebouweenheden_Adressen.ffs,DestDataset_FFS_5,..\data\output\BEW_Percelen.ffs,DestDataset_FFS_6,..\data\output\BEW_Eigendommen.ffs,DestDataset_FFS_11,..\data\output\BEW_Eigenaars.ffs,SourceDataset_FFS_14,..\data\intermediate\004\004_Gebouweenheden_Adressen.ffs,SourceDataset_FFS_10,..\data\intermediate\004\004_KAD_percelen.ffs,SourceDataset_FFS_11,..\data\intermediate\000\000_KAD.ffs,SourceDataset_FFS_8,..\data\intermediate\004\004_KAD_owner.ffs)} {005_BEW_CopyToOutput.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_8_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_8_FAILED
Tcl2 proc WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_summarizer { } {     global WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_process_count 0;     FME_SetAttribute _proc_count [set WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_process_count];     global WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_all_processes;     if {[info exists WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_all_processes]} {         set index 0;         foreach pid [set WorkspaceRunner_8_b835592a_c04b_4dcc_b341_3e417af4d3990_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME WorkspaceRunner_8_SummaryMaker    CREATE_AT_END yes

# -------------------------------------------------------------------------

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {WorkspaceRunner_Failed_8} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME WorkspaceRunner_Failed_8_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_8_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_8_FeatureDirector    INPUT  FEATURE_TYPE WorkspaceRunner_8_FAILED    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_8___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_8___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_Failed_8___FeatureDirector1    INPUT FEATURE_TYPE WorkspaceRunner_Failed_8___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_Failed_8___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_Failed_8___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_8_VectorSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_8___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc WorkspaceRunner_Failed_8_782c29ad_6558_4095_b640_77453c33c2020_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_8___PointCloudThinner    INPUT FEATURE_TYPE WorkspaceRunner_Failed_8___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_8_782c29ad_6558_4095_b640_77453c33c2020_thinPointCloud")
Tcl2 proc WorkspaceRunner_Failed_8_782c29ad_6558_4095_b640_77453c33c2020_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_Failed_8_RasterSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_Failed_8___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_Failed_8_782c29ad_6558_4095_b640_77453c33c2020_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# WorkspaceRunner_Failed_8_782c29ad_6558_4095_b640_77453c33c2020_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO WorkspaceRunner_Failed_8_782c29ad_6558_4095_b640_77453c33c2020_VIS_FEAT_TYPE WorkspaceRunner_Failed_8$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME WorkspaceRunner_Failed_8_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(WorkspaceRunner_Failed_8_782c29ad_6558_4095_b640_77453c33c2020_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA _creation_instance,varchar<openparen>255<closeparen>,_failure_message,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {WorkspaceRunner_8_Succeeded} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME WorkspaceRunner_8_Succeeded_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_8_Succeeded_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_8_Succeeded_FeatureDirector    INPUT  FEATURE_TYPE WorkspaceRunner_8_SUCCEEDED    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_8_Succeeded___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_8_Succeeded___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME WorkspaceRunner_8_Succeeded___FeatureDirector1    INPUT FEATURE_TYPE WorkspaceRunner_8_Succeeded___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE WorkspaceRunner_8_Succeeded___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE WorkspaceRunner_8_Succeeded___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_8_Succeeded_VectorSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_8_Succeeded___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc WorkspaceRunner_8_Succeeded_2f2013fb_0af3_499f_9f8a_067e8de9f4fb0_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_8_Succeeded___PointCloudThinner    INPUT FEATURE_TYPE WorkspaceRunner_8_Succeeded___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_8_Succeeded_2f2013fb_0af3_499f_9f8a_067e8de9f4fb0_thinPointCloud")
Tcl2 proc WorkspaceRunner_8_Succeeded_2f2013fb_0af3_499f_9f8a_067e8de9f4fb0_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME WorkspaceRunner_8_Succeeded_RasterSetterUpper    INPUT FEATURE_TYPE WorkspaceRunner_8_Succeeded___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("WorkspaceRunner_8_Succeeded_2f2013fb_0af3_499f_9f8a_067e8de9f4fb0_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# WorkspaceRunner_8_Succeeded_2f2013fb_0af3_499f_9f8a_067e8de9f4fb0_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO WorkspaceRunner_8_Succeeded_2f2013fb_0af3_499f_9f8a_067e8de9f4fb0_VIS_FEAT_TYPE WorkspaceRunner_8_Succeeded$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME WorkspaceRunner_8_Succeeded_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(WorkspaceRunner_8_Succeeded_2f2013fb_0af3_499f_9f8a_067e8de9f4fb0_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA _creation_instance,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

FACTORY_DEF * RoutingFactory FACTORY_NAME "Destination Feature Type Routing Correlator"   COMMAND_PARM_EVALUATION SINGLE_PASS   INPUT FEATURE_TYPE *   FEATURE_TYPE_ATTRIBUTE __wb_out_feat_type__   OUTPUT ROUTED FEATURE_TYPE *    OUTPUT NOT_ROUTED FEATURE_TYPE __nuke_me__ @Tcl2("FME_StatMessage 818059 [FME_GetAttribute fme_template_feature_type] 818060 818061 fme_warn")
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory   FACTORY_NAME "Final Output Nuker"   INPUT FEATURE_TYPE __nuke_me__

# -------------------------------------------------------------------------

FACTORY_DEF * CreationFactory   CREATE_AT_END   OUTPUT FEATURE_TYPE __NUKEME__   @TCL("if [file exists {$(WORKSPACE_TEMP_DIR)}] {set files [glob -nocomplain -directory  {$(WORKSPACE_TEMP_DIR)} -tails *.ffs];   if {[llength $files] == 1} {    set theFile {$(WORKSPACE_TEMP_DIR)/};   append theFile [lindex $files 0];   eval FME_Execute System \173\042$(FME_HOME_UNIX)/fmedatainspector\042 --visualizer --single-application --delete-on-close --no-source-prompt -f FFS $theFile & \175;  } elseif { [llength $files] == 0 } {  catch { file delete -force {$(WORKSPACE_TEMP_DIR)} };  } else {  set filesNoExt {}; set lastfile {}; foreach {fileName} [lsort $files] { set fileNoExt [string trimright $fileName {.ffs}]; if [regexp {(.*)_[0-9]*$} $fileNoExt wholething fileNoExtBase] {  if { $fileNoExtBase == $lastfile } { continue } }; set lastfile $fileNoExt; lappend filesNoExt $fileNoExt };  eval FME_Execute System \173\042$(FME_HOME_UNIX)/fmedatainspector\042 --visualizer --single-application --delete-on-close --no-source-prompt -d {$(WORKSPACE_TEMP_DIR)} -a ffs -f FFS $filesNoExt & \175; }; }; ")
FACTORY_DEF * TeeFactory   INPUT FEATURE_TYPE __NUKEME__
